## SEO是 search Engine Optimization   （搜索引擎优化）

SEO：

①白帽SEO（普通SEO做的优化）

- 网站标题、关键字、描述
- 网站内容优化
- Robot.txt文件
- 网站地图
- 增加外链引用

②黑帽SEO

- 哥们你不做那种（嘻嘻）网站应该不太需要吧！

现在我说说前端工程师的SEO

①网站结构布局

- 扁平化结构
  - 控制首页链接数量（中小型网站<=100）
  - 目录层次不要太复杂（一般不要超过三层   三层之后基本很难被爬到啦）
  - 根据内容使用合理的 HTML标签
  - 面包屑导航（![img](https://images2015.cnblogs.com/blog/1026332/201611/1026332-20161122220310284-650029915.png)）
  - 对于图片一定要记得设置title alt 等属性
  - 分页使用     首页  1 2 3 4 5 ...  尾页  的模式    ...通过下拉列表去做吧

②网页代码优化 

- <title>标题

- <meta  keywords>关键字

- <meta  description>网页描述

- 代码语义化

- 尽量不要使用iframe框架

#### DNS 的全称是 ***Domain Name System\***（域名系统，或者常称为域名解析系统）。

#### CDN解决的是如何将数据快速可靠从源站传递到用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。

以下两点不属于SEO 但是对于前端工程师至关重要

　　一、加载

　　　　①你需要了解当你输入网页地址后 敲回车后发生什么

1. 1. 通过DNS按照http协议解析域名
   2. 发起TCP的3次握手
   3. 在建立TCP连接后发起http请求
   4. 服务器响应http请求，浏览器得到html代码
   5. 浏览器解析html代码，并请求html代码中的资源（如js脚本、css样式、图片资源等)
   6. 浏览器对页面进行渲染呈现给用户

　　二、渲染

- 外部样式会阻塞后续脚本的执行，直到外部样式加载并解析完毕

　　　　①浏览器解析html源码、然后创建一个DOM树

　　　　②浏览器解析css代码，并计算出最终的样式-css rules

　　　　③构建出DOM树，并计算出样式数据后，就会构建一个渲染树（render tree）

　　　　　　渲染树和DOM树很相似，只是会把DOM树中不需要渲染的节点忽略掉，比如：header、display：none 等。另外一点不同是会在节点上存储对应的css样式。

　　　　④渲染树构建好了就可以绘制到屏幕上了

```
  （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。
  （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
  （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
  （4） 当需要设置的样式很多时设置className而不是直接操作style。
  （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。
  （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。
  （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。
  （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
```

```
2. 为什么搜索引擎优化效果好（SEO）？
搜索引擎在做网页排名的时候，要根据网页的内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别html内容的，而我们每个页面所有的内容都放在html中，所以这种多页应用SEO排名效果好。
```

#### TCP协议全称: 传输控制协议, 顾名思义, 就是要对数据的传输进行一定的控制. 

```
三次握手

第一次: 
客户端 - - > 服务器 此时服务器知道了客户端要建立连接了 
第二次: 
客户端 < - - 服务器 此时客户端知道服务器收到连接请求了 
第三次: 
客户端 - - > 服务器 此时服务器知道客户端收到了自己的回应

到这里, 就可以认为客户端与服务器已经建立了连接.
```

为什么不用两次?

主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。 
##### 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没